https://goplay.space/ - можно поиграться с GoLang

Управляющие конструкции в GO
1)for
- cstyle - for i := 0; i < n; i++ {}
- while  - for hasMoreRows {}
- бесконечный (нужен хотя бы 1 бреак) - for {break}
2) if something {} else {}
3) switch
- классический со значением
- без значения



Объявление переменных в GO
1) var a int = 3 - стандартное долгое объявление переменной с ее типом
2) var a = 3 - будет установлен тип по дефолту
3) a := 3 - оператор моржа
4) var a int - объявить переменную с ZERO VALUE (нулевое значение)

Простые типы
- byte, rune, int, int8, int16, int32, int64, uint16, uint32, uint64
- float32, float64
- bool
- string

Составные типы
- массивы - фиксированный размер, однородные данные, не расширяемые, можно итерировать
- слайс - (это указатель на область памяти, длинна, капасити те вместимость число указатель от начала до конца памяти)
----содержит однородные данные, под капотом ссылается на массив, обращается к элементу с 0 (как в С), расширяется через append, нелувое значение = nil, НЕ УНИКАЛЬНЫЕ как в ts
- мап - map
---- содержат ключ и значение, автоматисчески расширяются, константное время доступа, можно проверить присутствие или отсутсвие элемента, можно итерировать for range
---- всегда нужно инициализировать (нулевое значение это nil, туда нельзя будет вставлять новые данные)
- структуры - как struct в С, может состоять из любых типов, необъявленные поля заполняются нулевыми значениями, нулевое значение - все поля нулевое

УКАЗАТЕЛЬ - адрес в памяти где лежит переменная (кладется в КУЧУ, обычные переменные в стеке)
----РАЗЫМЕНОВАНИЕ УКАЗАТЕЛЯ - получение значения указателя (берем знаяение из памяти, что то с ней делаем, кладем обратно)

ССЫЛОЧНЫЕ ТИПЫ
- указатель
- слайс
- map

ФУНКЦИИ
- передаются, возвращаются, вызываются в других функциях

- РЕЛОКАЦИЯ В СЛАЙСАХ - размещение нового массива в другой области памяти

СОБСТВЕННЫЕ ТИПЫ (позволяют объявлять собственные методы,_разные типы поулчателя по значению или указателю, для работы может потребоваться приведение типов)
- из структур
- из примитивов
- из массивов
- из указателя (получается неким алиасом) - type PointerTypeInt *int
- по сути почти из чего угодно


ИНТЕРФЕЙСЫ
- только контракт (набор методов)
- один интерфейс можно встроить другой интерфейс
- если в типе не реализовать интерфес то уомпилятор не пропустит
- zero-value = nil
- на интерфейсы можно взять указатели, но обычно так не делают
- компилятор не смотрит на лишние методы которые мы дописываем интерфесу
- может быть пустым, нужен редко, но впринципе нужен для any из JS (interface{})
- можно инкапсуляцию но ее не используют (размещение в одном компоненте данных и методов окторые с ним работают)
- полиморфизм - дженерики
- псевдонаследование -  не полное наследование 
- некоторые считаю что интерфейсы нужны только для уменьшения связанности приложений
* интерфейс - это абстракция над стандартным типом, позволяющая разорвать связь между реализацией и использованием.
описываются там где используются (прям рядом с бизнес логикой) и описывают только то что используется (ридер интерфейс рядом с ридером, райдер с райдером)
##### инты применяются в
- простые рядом с бизнес логикой
- системная библиотека (error плохой пример)
- Data Acces Layer
- мок-объекты для юнит тестов (есть генераторы интов для этого)
- type switch
- nil != nil (интерфейса)
кароче интерфейсы это декоуплинг и полиморфизм


INT vs int64 sv uint64 и т.д.
- int - для вычелсения длинны массива или конкретной функции
- int64 - обчыно для всего остального
- uint64 - только целые числа с большим диапозоном положительных значений
* чем меньше int - тем меньше памяти он занимает (8 - 1 байт, 16 - 2 байта, 32 - 4 байта, 64 - 8 байт) 


СТРОКА под капотом - slice of bytes

ЕСКЕЙП АНАЛИЗ - GoLang анализирует ...

ПРИ ПЕРЕПОЛНЕНИИ СТЕКА GoLang кладет переменные в кучу.





MODULE МОДУЛИ
- все файлы в папке должны соответсвовать имени папки (кроме юнит тестов)
- файлики в одной папке и именем одного пакета видят все что написано в соседних файлах
- func init() {} - выполянется при загрзке модуля
- в go нет проблемы пакетов в глобальном окружении - можно качать что хочеш а проекты будут использовать то что нужно
- модули ставятся в go/pkg/mod (еще есть go/mod/src или была раньше)
- // inderect - в mod файле говорит о том что зависимоть не используется
- requeire - когда нужен пакет из сети
- replace - когда нужен пакет локальный
- go модули использующие одну библиотеку, должны использовать библиотеку одной версии
- go private - скачать приватные репозитории (еще можно использовать go-proxy)

go mod init - инициализация
go get github.com/google/uuid - затянуть репозиторий
go get -u github.com/google/uuid - обновить репозиторий
go mod download - скачать пакеты локально (go build и go test тоже качают)
go mod tidy - удалить неиспользуемые модули, обновить файл go.sum, скачать отсутствующие зависимости (с обновлением)

делаем Makefile и пишем
.PHONY: run
run:
	go run cmd/storage/main.go

make run 

ФАЙЛОВАЯ СТРУКТУРА
- internal - приватная папка, другие пакеты ее не видят
- cmd - папка для входа в программу (main.go - самый тонкий файл для входа в программу)
- pkg - торчит наружу для экспорта, обычно для экспорта кода клиентов
- api - для микросервисов (апишка)





-- КОНКУРЕНТНОЕ ПРОГРАММИРОВАНИЕ
Параллельность - возможность выполнять код одновременно в нескольких потоках
Конкурентность - возможность передавать управление другому потоку в процессе выполнения кода

Процессы - все свое, память, ресурсы и т.д.

GO-рутина - это КО-рутина
Рантайм GO - по сути библиотека а не рантайм как в других языках
- виртуальный процессор Р - представляет каждое виртуальное ядро или поток гипертрединга (интеловская тема которая)
- реальный ПОТОК ОС для рантайма ГО - М - создается по числу виртуальных процессоров
- горутинка - создается по необходимости, как минимум одна для main 
- горутины перемещаются между ПОТОКАМИ и ВИРТУАЛЬНЫМИ ПРОЦЕССОРАМИ
- горутина весит 2кб (ее стек)
- в процессе выполнения стек может увеличиваться максимум до 1гб
- СОЗДАЕТСЯ ЛЕГКО - пишем перед функцией go (go func() {})

Канал - очередь сообщений которая умеет работать в многопоточной среде
- intChannel := make(chan int) - открыть
- нулевое значение nil
- close(intChannel) - закрыть канал
- можно создать канал каналов
- буферезированный канал - канал в котором есть место для нескольких сообщений
- cap(intChannel) - размер канала
- len(intChannel) - текущая длина канала
- for v := range intChannel {...} - самый удобный способ читать канал т.кю не нужно следить за тем чо он закончился
- select switch - позволяет выбрать разные ветки в канале
ВАЖНЫЕ ПРАВИЛА каналов
1 - закрывает канал тот кто в него пишет
2 - если несколько продюсеров, то канал закрывает то кто создал его и продюсеров
3 - не закрытый канал жрет ресурсы, закрывайте их явно


В КАНАЛЕ ЕСТЬ MUTEX - штука для синхронизации потоков (лок и анлок)
- только одна горутина
- передаем по ссылке (&)
- анлок свободного mutex приведет к панике
- повторный лок занятого мютекса приведет к дедлоку
RWNUTEX
- можно блокировать ЗАПИСЬ и ЧТЕНИЕ отдельно
- дает прирост производительности если много чтения и мало записи (при залоченом чтении

SYNC MAP - асинхронная мапа, но нужна только когда харинм +1ЛЯМ записей иначе мутексы быстрее

ATOMIC (АТОМИКИ) - потокобезопасный способ выолнить операцию гарантированно за 1 такт
- atomiValue - позволяет хранить любой интерфейс (структуру)
- всегда работает с указателем

CONTEXT - объект который можно передавать между асинхронными конструкциями





ТЕСТЫ
- можно паралелить "t.Parallel()"
- можно генерить во многих ИДЕшках
- хорошие моки в пакете gomok, но моки автогенераций не особо сильно катируются (но собственные интерфейсы можно накидать руками)


