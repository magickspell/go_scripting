https://goplay.space/ - можно поиграться с GoLang

Управляющие конструкции в GO
1)for
- cstyle - for i := 0; i < n; i++ {}
- while  - for hasMoreRows {}
- бесконечный (нужен хотя бы 1 бреак) - for {break}
2) if something {} else {}
3) switch
- классический со значением
- без значения



Объявление переменных в GO
1) var a int = 3 - стандартное долгое объявление переменной с ее типом
2) var a = 3 - будет установлен тип по дефолту
3) a := 3 - оператор моржа
4) var a int - объявить переменную с ZERO VALUE (нулевое значение)

Простые типы
- byte, rune, int, int8, int16, int32, int64, uint16, uint32, uint64
- float32, float64
- bool
- string

Составные типы
- массивы - фиксированный размер, однородные данные, не расширяемые, можно итерировать
- слайс - (это указатель на область памяти, длинна, капасити те вместимость число указатель от начала до конца памяти)
----содержит однородные данные, под капотом ссылается на массив, обращается к элементу с 0 (как в С), расширяется через append, нелувое значение = nil, НЕ УНИКАЛЬНЫЕ как в ts
- мап - map
---- содержат ключ и значение, автоматисчески расширяются, константное время доступа, можно проверить присутствие или отсутсвие элемента, можно итерировать for range
---- всегда нужно инициализировать (нулевое значение это nil, туда нельзя будет вставлять новые данные)
- структуры - как struct в С, может состоять из любых типов, необъявленные поля заполняются нулевыми значениями, нулевое значение - все поля нулевое

УКАЗАТЕЛЬ - адрес в памяти где лежит переменная (кладется в КУЧУ, обычные переменные в стеке)
----РАЗЫМЕНОВАНИЕ УКАЗАТЕЛЯ - получение значения указателя (берем знаяение из памяти, что то с ней делаем, кладем обратно)

ССЫЛОЧНЫЕ ТИПЫ
- указатель
- слайс
- map

ФУНКЦИИ
- передаются, возвращаются, вызываются в других функциях

- РЕЛОКАЦИЯ В СЛАЙСАХ - размещение нового массива в другой области памяти

СОБСТВЕННЫЕ ТИПЫ (позволяют объявлять собственные методы,_разные типы поулчателя по значению или указателю, для работы может потребоваться приведение типов)
- из структур
- из примитивов
- из массивов
- из указателя (получается неким алиасом) - type PointerTypeInt *int
- по сути почти из чего угодно


ИНТЕРФЕЙСЫ
- только контракт (набор методов)
- один интерфейс можно встроить другой интерфейс
- если в типе не реализовать интерфес то уомпилятор не пропустит
- zero-value = nil
- на интерфейсы можно взять указатели, но обычно так не делают
- компилятор не смотрит на лишние методы которые мы дописываем интерфесу
- может быть пустым, нужен редко, но впринципе нужен для any из JS (interface{})
- можно инкапсуляцию но ее не используют (размещение в одном компоненте данных и методов окторые с ним работают)
- полиморфизм - дженерики
- псевдонаследование -  не полное наследование 
- некоторые считаю что интерфейсы нужны только для уменьшения связанности приложений
* интерфейс - это абстракция над стандартным типом, позволяющая разорвать связь между реализацией и использованием.
описываются там где используются (прям рядом с бизнес логикой) и описывают только то что используется (ридер интерфейс рядом с ридером, райдер с райдером)
##### инты применяются в
- простые рядом с бизнес логикой
- системная библиотека (error плохой пример)
- Data Acces Layer
- мок-объекты для юнит тестов (есть генераторы интов для этого)
- type switch
- nil != nil (интерфейса)
кароче интерфейсы это декоуплинг и полиморфизм


INT vs int64 sv uint64 и т.д.
- int - для вычелсения длинны массива или конкретной функции
- int64 - обчыно для всего остального
- uint64 - только целые числа с большим диапозоном положительных значений
* чем меньше int - тем меньше памяти он занимает (8 - 1 байт, 16 - 2 байта, 32 - 4 байта, 64 - 8 байт) 


СТРОКА под капотом - slice of bytes

ЕСКЕЙП АНАЛИЗ - GoLang анализирует ...

ПРИ ПЕРЕПОЛНЕНИИ СТЕКА GoLang кладет переменные в кучу.





MODULE МОДУЛИ
- все файлы в папке должны соответсвовать имени папки (кроме юнит тестов)
- файлики в одной папке и именем одного пакета видят все что написано в соседних файлах
- func init() {} - выполянется при загрзке модуля
- в go нет проблемы пакетов в глобальном окружении - можно качать что хочеш а проекты будут использовать то что нужно
- модули ставятся в go/pkg/mod (еще есть go/mod/src или была раньше)
- // inderect - в mod файле говорит о том что зависимоть не используется
- requeire - когда нужен пакет из сети
- replace - когда нужен пакет локальный
- go модули использующие одну библиотеку, должны использовать библиотеку одной версии
- go private - скачать приватные репозитории (еще можно использовать go-proxy)

go mod init - инициализация
go get github.com/google/uuid - затянуть репозиторий
go get -u github.com/google/uuid - обновить репозиторий
go mod download - скачать пакеты локально (go build и go test тоже качают)
go mod tidy - удалить неиспользуемые модули, обновить файл go.sum, скачать отсутствующие зависимости (с обновлением)

делаем Makefile и пишем
.PHONY: run
run:
	go run cmd/storage/main.go

make run 

ФАЙЛОВАЯ СТРУКТУРА
- internal - приватная папка, другие пакеты ее не видят
- cmd - папка для входа в программу (main.go - самый тонкий файл для входа в программу)
- pkg - торчит наружу для экспорта, обычно для экспорта кода клиентов
- api - для микросервисов (апишка)





-- КОНКУРЕНТНОЕ ПРОГРАММИРОВАНИЕ
Параллельность - возможность выполнять код одновременно в нескольких потоках
Конкурентность - возможность передавать управление другому потоку в процессе выполнения кода

Процессы - все свое, память, ресурсы и т.д.

GO-рутина - это КО-рутина
Рантайм GO - по сути библиотека а не рантайм как в других языках
- виртуальный процессор Р - представляет каждое виртуальное ядро или поток гипертрединга (интеловская тема которая)
- реальный ПОТОК ОС для рантайма ГО - М - создается по числу виртуальных процессоров
- горутинка - создается по необходимости, как минимум одна для main 
- горутины перемещаются между ПОТОКАМИ и ВИРТУАЛЬНЫМИ ПРОЦЕССОРАМИ
- горутина весит 2кб (ее стек)
- в процессе выполнения стек может увеличиваться максимум до 1гб
- СОЗДАЕТСЯ ЛЕГКО - пишем перед функцией go (go func() {})

Канал - очередь сообщений которая умеет работать в многопоточной среде
- intChannel := make(chan int) - открыть
- нулевое значение nil
- close(intChannel) - закрыть канал
- можно создать канал каналов
- буферезированный канал - канал в котором есть место для нескольких сообщений
- cap(intChannel) - размер канала
- len(intChannel) - текущая длина канала
- for v := range intChannel {...} - самый удобный способ читать канал т.кю не нужно следить за тем чо он закончился
- select switch - позволяет выбрать разные ветки в канале
ВАЖНЫЕ ПРАВИЛА каналов
1 - закрывает канал тот кто в него пишет
2 - если несколько продюсеров, то канал закрывает то кто создал его и продюсеров
3 - не закрытый канал жрет ресурсы, закрывайте их явно


В КАНАЛЕ ЕСТЬ MUTEX - штука для синхронизации потоков (лок и анлок)
- только одна горутина
- передаем по ссылке (&)
- анлок свободного mutex приведет к панике
- повторный лок занятого мютекса приведет к дедлоку
RWNUTEX
- можно блокировать ЗАПИСЬ и ЧТЕНИЕ отдельно
- дает прирост производительности если много чтения и мало записи (при залоченом чтении

SYNC MAP - асинхронная мапа, но нужна только когда харинм +1ЛЯМ записей иначе мутексы быстрее

ATOMIC (АТОМИКИ) - потокобезопасный способ выолнить операцию гарантированно за 1 такт
- atomiValue - позволяет хранить любой интерфейс (структуру)
- всегда работает с указателем
- атомики быстрее мутексов, но они не про синхронизацию данных
- работают на тактах процессора, поэтому изолированны (а в джаве нужна синхра в похожих кейсах тк она на виртуалке)

ТРЕДОВ в go нет, но грубо говоря они равны кол-ву ядер процесора (с гипертредингом)
НО МУТЕКС синхронизирует данные между потоками (по точкам лока и анлока) или КАНАЛЫ (сами по себе уже все делают)

CONTEXT - объект который можно передавать между асинхронными конструкциями
- можео закрывать вручную и по таймауту




ТЕСТЫ (Test_NameFunc)
- можно паралелить "t.Parallel()"
- можно генерить во многих ИДЕшках
- хорошие моки в пакете gomok, но моки автогенераций не особо сильно катируются
(но собственные интерфейсы можно накидать руками)
- ЕЩЕ ЕСТЬ БЕНЧМАРКИ! (Benchmark_NameFunction) НО ОНИ ТОЛЬКО ДЛЯ ЗАМЕРА СКОРОСТЕЙ
- BenchmarkMutexCounter-8(имя функции, кол-во процессоров)     	     968(кол-во выполненных операций)	   1467714 ns/op()
- бенчамарки запускаются последовательно и не мешают друг другу
- бенчмарки можно построить графики, посчитать расходы памяти
- go test -bench ..file -race=1 - способ найти редко воспроизводимые кейсы


ВЫСОКОНАГРУЖЕННЫЙ КЕШ
- уменьшение нагрузки
- уменьшаем rt (времени ответа?)
МЕТОДЫ КЕША это атомарные операции
- get
- put
- delete
- getMulti (много гетов, редко)
- deleteMulti (много удалений, редко)


ПРАВИЛЬНАЯ МНОГОПОТОЧКА
- горутины (асинхронные функции)
- атомики (выполнение за один такт - не мешаем другим горутинам)
- мутексы (потокобезопасность)





JSON
MARSHAL - парсит в строчку
MARSHAL INDENT - парсит и вставляет префиксы и инденты
UNMARSHAL - используется для преобразования JSON-данных в структуру
--Интерфейсы маршалеров JSON нужны для переопределения, пропуска пустых или игнорирования полей, доступа к приватным полям.
--ТЕГИ JSON:
type myStruct struct {
    // Будет использовать название и тип поля
    Field1 int
    // Изменено название
    Field2 int `json:"renamedField2"`
    // Вырезается zero-value и изменено название
    Field3 int `json:"renamedField3,omitempty"`
    // Вырезается zero-value
    Field4 int `json:",omitempty"`
    // Поле игнорируется
    Field5 int `json:"-"`
    // Поле будет называться `-`
    Field6 int `json:"-,"`
    // Примет строковое представление (слишком большое число для JS)
    Int64String int64 `json:",string"`
}
--либы для жсона (но нужны редко)
json-iterator/go
easy/json
std



/***///*/*/*/*/*/*/*/*/*
HTTP клиент
-Имеется встроенный пакет net для работы с сетью и подпакет net/http дляработы с HTTP
--не используйте стандартный http.DefaultClient
--используйте контекст с ограничением по времени
--не читайте из io.Reader больше одного раза
http.Client:
'''
import "net/http"
http.Client{
    Transport
    // Как каждый запрос будет сделан, RoundTripper интерф
    CheckRedirect // Функция, определяющая политику работы редиректа
    Jar:
    // Общее хранилище cookie
    Timeout:
    // Лимит времени выполнения запросов
}
'''
--ДЛЯ HTTP-1 нужно переопределать MaxIdConnsPerHost в большую сторону!!!
- эталонный вариант запросов через контекст (3contextHttp)


HTTP SERVER
-http.ListenAndServe("127.0.0.1:8080", nil)
-блокирующая функция
-под капотом функции nte.Listen и потом http.Serve
-аргумент адрес принимает ip:port но можно указать только порт, тогда сервер будет на всех ИП машины
-всегда возвращает ошибку
-----если не запустился
-----при вызове Shutdown кидает ошибку http.ErrServerClosed
-Интерфейс http.Handler
```
    type Handler interface {
        ServeHTTP(ResponseWriter, *Request)
    }
```
-Обработчик handler func(ResponseWriter, *Request)
----Интерфейс http.ResponseWriter позволяет записать заголовки и тело ответа
----Структура *http.Request содержит:
1)контекст запроса
2)информацию о запросе
3)payload запроса
-если http.Handler передан как nil, то будет использваться http.DefaultServeMux
- в стандартном мультиплексере паттерн / работает как fallback для всех запросов.
- скорее всего придется подключать мультиплексер как библиотеку, потомукак стандартного очень быстро станет недостаточно
- для тестов есть пакет net/http/httptest и структура httptest.ResponseRecorder
- Content-Length выставляется автоматически, можно переопределить
- нужно самостоятельно указывать Content-Type, иначе под капотом будет
- вызываться “дорогая” функция http.DetectContentType (лучше всегда явно указывать application/json)

GRACEFULL SHUTDOWN - КОРРЕКТНОЕ ЗАВЕРШЕНИЕ СЕРВИСА
- делаем горутину и залипаем ее через листенСерве
- делаем канал слушаем пока нам не дадут команды выключение (sigint)
- когда получаем команду завершения - делаем контекст завершения с временем большим чем время ответа сервера
- выключаем сервер - server.Shutdown(closeCtx)
- ЕЛСИ у нас несколько серверов - то делаем waitGroup и делаем тоже самое что и с одним сервером





PROTOCOL BUFFERS (protobuf) - мормат типа JSON, но занимает меньше места, дружит со многими языками
- (пишем файл name.proto и потом генерим его в нужный язык)
- меньше весит (эффективный бинарный формат)
- для (де)кодирования нужно знать схему
- парсеры/сериализаторы генерируются для многих языков
- фокус на обратную совместимость
- поля нумерованы - при передачи не передаются названия полей
- поля могут быть отдельными сообщениям (типа вложенности объектов)
- поля могут быть массивы (repeated)
- поля могут быть ЕНУМЫ
- поля могут быть МАПЫ
- для генерации надо (sudo apt install -y protobuf-compiler)
''''''
    или (
    docker run --rm -v $(pwd):/workspace bufbuild/buf generate --template /workspace/buf.gen.yaml
    docker run --rm -v $(pwd):/workspace bufbuild/buf:1.32 generate --template /workspace/buf.gen.yaml
    )
    установка для ГО (
    sudo apt install protobuf-compiler
    sudo apt install golang-goprotobuf-dev

    можно пробовать запускать: protoc -I=protos --go_out=go/pb protos/my/my.proto --go_opt=source_relative
       объяснение команды:                      --указвае ЯП и в какую папку выводить ____ папка до прото-файла  --доп опция для компиляции для go

    если не получается пробуем
    $ export GOPATH=$HOME/go
    $ export PATH=$PATH:$GOPATH/bin

    export GO_PATH=~/go
    export PATH=$PATH:/$GO_PATH/bin
)
''''''
- в протобафах отличить ноль от отсутсвующего значения долгое вроемя было нельзя
но теперь появились врапперы, через которые можно узнать пустой или нет message
поэтому во ваперы заворачивают простые скалярные параметры, ниже пример такого врапера
"""
import "google/protobuf/wrappers.proto";

message ParamValue {
    oneof value_oneof {
        google,protobuf.StringValue str = 1;
        google,protobuf.Int64Value int = 2;
        google,protobuf.BoolValue bool = 3;
    }
}
"""
- еще есть библиотека timestamp от гугла, там есть тип EMPTY - пустое поле (вроде единственное полезное оттуда)
- ОБРАТНАЯ СОВМЕСТИМОСТЬ
1 нельзя менять номер существующего поля
2 можно убирать и добавлять поля
3 нельзя добавлять новое поле на место старого номера (reserved)
4 можно добавлять и удалять repeated (масивы) для string и bytes сообщений





GRPC
- RPC (remote procedure call) - на базе protocolbuffers - удаленный вызов процедур
- работает поверх HTTP/2 (в озоне передаются без шифрования т.к. оно уже зашифровано само по себе)
- есть свои ошибки типа как 400, 404, 500 и т.д.
- ответ GRPC может быть протобафом или стримом (несколько сообщений)
- есть библа grpc-gateway, которая генерит HTTP ручки для GRPC методов и свагер для них
- в OZON они выносили сгенерировыннй протобаф сервиса в доп модуль в папку pkg



POSTGRESQL
- на 8 поточный процессор - 14-15 одновременных запросов можно выполнять в PGSQL
- 1000 запросов в очереди это норма
- postmaster - процесс который рулит всей БД
- vacuum - утилита для удаления старых закешированных запросов (ненужные строки, транзакции, статистику)
для всей БД или конкретной таблицы
- пул соеденений (макс кол-во соеденений) = ?10? (макс = max_connections - superuser_reserved_connections)
- для пулов есть еще PGBOUNCER.ORG
- большие ограничения на объемы данных которые сложно првезойти
- индкесы по умолчанию b-tree (еще есть hash, gist,sp-gist, gin, brin)
- транзакционность (вложенность, изолированность, 3 уровня, read commited)
- ПАРТИЦИРОВАНИЕ - разбитие большой таблицы на несколько таблиц по ключу партицирование (какоето условие)
- ШАРДЖИРОВАНИЕ - разбиение большой базы на несколько БД (серверов)
- популярный драйвер для POSTGRESQLL github.com/lib/pq github.com/go-pg/pg github.com/uptrace/bun
вроде самй популярный драйвер - github.com/jackc/pgx/v4
- для миграций есть библа GOOSE
- для тестов фикстуры (github.com/go-testfixtures/testfixtures) (наполнение данными бд)
- NULL в SQL это не NULL в GOLANG - для этого используются обертки NullInt64
- для защиты от скл-иньекций используются плейсхолдеры $1, $2, $3 и т.д. (но например для названий таблиц плейсхолдеры нельзя использовать)
- sqlx, squrrel - две библы для работы с скл в го
















