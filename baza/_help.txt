https://goplay.space/ - можно поиграться с GoLang

Управляющие конструкции в GO
1)for
- cstyle - for i := 0; i < n; i++ {}
- while  - for hasMoreRows {}
- бесконечный (нужен хотя бы 1 бреак) - for {break}
2) if something {} else {}
3) switch
- классический со значением
- без значения



Объявление переменных в GO
1) var a int = 3 - стандартное долгое объявление переменной с ее типом
2) var a = 3 - будет установлен тип по дефолту
3) a := 3 - оператор моржа
4) var a int - объявить переменную с ZERO VALUE (нулевое значение)

Простые типы
- byte, rune, int, int8, int16, int32, int64, uint16, uint32, uint64
- float32, float64
- bool
- string

Составные типы
- массивы - фиксированный размер, однородные данные, не расширяемые, можно итерировать
- слайс - (это указатель на область памяти, длинна, капасити те вместимость число указатель от начала до конца памяти)
----содержит однородные данные, под капотом ссылается на массив, обращается к элементу с 0 (как в С), расширяется через append, нелувое значение = nil, НЕ УНИКАЛЬНЫЕ как в ts
- мап - map
---- содержат ключ и значение, автоматисчески расширяются, константное время доступа, можно проверить присутствие или отсутсвие элемента, можно итерировать for range
---- всегда нужно инициализировать (нулевое значение это nil, туда нельзя будет вставлять новые данные)
- структуры - как struct в С, может состоять из любых типов, необъявленные поля заполняются нулевыми значениями, нулевое значение - все поля нулевое

УКАЗАТЕЛЬ - адрес в памяти где лежит переменная (кладется в КУЧУ, обычные переменные в стеке)
----РАЗЫМЕНОВАНИЕ УКАЗАТЕЛЯ - получение значения указателя (берем знаяение из памяти, что то с ней делаем, кладем обратно)

ССЫЛОЧНЫЕ ТИПЫ
- указатель
- слайс
- map

ФУНКЦИИ
- передаются, возвращаются, вызываются в других функциях

- РЕЛОКАЦИЯ В СЛАЙСАХ - размещение нового массива в другой области памяти

СОБСТВЕННЫЕ ТИПЫ (позволяют объявлять собственные методы,_разные типы поулчателя по значению или указателю, для работы может потребоваться приведение типов)
- из структур
- из примитивов
- из массивов
- из указателя (получается неким алиасом) - type PointerTypeInt *int
- по сути почти из чего угодно


ИНТЕРФЕЙСЫ
- только контракт (набор методов)
- один интерфейс можно встроить другой интерфейс
- если в типе не реализовать интерфес то уомпилятор не пропустит
- zero-value = nil
- на интерфейсы можно взять указатели, но обычно так не делают
- компилятор не смотрит на лишние методы которые мы дописываем интерфесу
- может быть пустым, нужен редко, но впринципе нужен для any из JS (interface{})
- можно инкапсуляцию но ее не используют (размещение в одном компоненте данных и методов окторые с ним работают)
- полиморфизм - дженерики
- псевдонаследование -  не полное наследование 
- некоторые считаю что интерфейсы нужны только для уменьшения связанности приложений
* интерфейс - это абстракция над стандартным типом, позволяющая разорвать связь между реализацией и использованием.
описываются там где используются (прям рядом с бизнес логикой) и описывают только то что используется (ридер интерфейс рядом с ридером, райдер с райдером)
##### инты применяются в
- простые рядом с бизнес логикой
- системная библиотека (error плохой пример)
- Data Acces Layer
- мок-объекты для юнит тестов (есть генераторы интов для этого)
- type switch
- nil != nil (интерфейса)
кароче интерфейсы это декоуплинг и полиморфизм


INT vs int64 sv uint64 и т.д.
- int - для вычелсения длинны массива или конкретной функции
- int64 - обчыно для всего остального
- uint64 - только целые числа с большим диапозоном положительных значений
* чем меньше int - тем меньше памяти он занимает (8 - 1 байт, 16 - 2 байта, 32 - 4 байта, 64 - 8 байт) 


СТРОКА под капотом - slice of bytes

ЕСКЕЙП АНАЛИЗ - GoLang анализирует ...

ПРИ ПЕРЕПОЛНЕНИИ СТЕКА GoLang кладет переменные в кучу.





MODULE МОДУЛИ
- в go нет проблемы пакетов в глобальном окружении - можно качать что хочеш а проекты будут использовать то что нужно
- модули ставятся в go/pkg/mod (еще есть go/mod/src или была раньше)
- // inderect - в mod файле говорит о том что зависимоть не используется
- requeire - когда нужен пакет из сети
- replace - когда нужен пакет локальный
- go модули использующие одну библиотеку, должны использовать библиотеку одной версии
- go private - скачать приватные репозитории (еще можно использовать go-proxy)

go mod init - инициализация
go get github.com/google/uuid - затянуть репозиторий
go get -u github.com/google/uuid - обновить репозиторий
go mod download - скачать пакеты локально (go build и go test тоже качают)
go mod tidy - удалить неиспользуемые модули, обновить файл go.sum, скачать отсутствующие зависимости (с обновлением)

делаем Makefile и пишем
.PHONY: run
run:
	go run cmd/storage/main.go

make run 

ФАЙЛОВАЯ СТРУКТУРА
- internal - приватная папка, другие пакеты ее не видят
- cmd - папка для входа в программу (main.go - самый тонкий файл для входа в программу)
- pkg - торчит наружу для экспорта, обычно для экспорта кода клиентов
- api - для микросервисов (апишка)






